<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>jsgame</title>
	<style>
		html,
		body {
			height: 100%;
			width: 100%;
			
			align-items: center;
			display: flex;
			justify-content: center;
			
			background-color: #1f2424;
			margin: 0;
		}
	</style>
</head>
<body>
	<script src="./vendor/pixijs/pixi.min.js"></script>
	<script src="./vendor/matter-js-0.12.0/build/matter.min.js"></script>
	
	<noscript>
		This site needs Javascript to function.
		Enable it or enjoy this blank page.
	</noscript>

	<!-- Game -->
	<script>


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////   END OF ENGINE   ////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
		const keycode = {
			W: 87,
			A: 65,
			S: 83,
			D: 68,
			P: 80,
			SPACE: 32,
			ESCAPE: 27
		};
		Object.freeze(keycode);
		
		const Key = {
			_pressed: {},
			
			isDown: function(keyCode) {
				return this._pressed[keyCode];
			},
			
			onKeydown: function(event) {
				if(this._pressed[event.keyCode] === undefined) {
					this._pressed[event.keyCode] = new Date().getTime();
				}
			},
			
			onKeyup: function(event) {
				delete this._pressed[event.keyCode];
			}
		};

		// Global state of the application
		const state = {
			app: undefined,
			player: {
				sprite: undefined,
				speed: 7,
				body: undefined
			},
			isPaused: false,
			engine: undefined,
			entities: []
		};


		function addTextWithBody(text, x, y, bodyConfig) {
			const style = new PIXI.TextStyle({
				fontFamily: 'Arial',
				fontSize: 36,
				fontStyle: 'italic',
				fontWeight: 'bold',
				fill: ['#ffffff', '#00ff99'], // gradient
				stroke: '#4a1850',
				strokeThickness: 5,
				dropShadow: true,
				dropShadowColor: '#000000',
				dropShadowBlur: 4,
				dropShadowAngle: Math.PI / 6,
				dropShadowDistance: 6,
				wordWrap: true,
				wordWrapWidth: 440
			});

			const sprite = new PIXI.Text(text, style);
			sprite.x = x;
			sprite.y = y;
			sprite.anchor.set(0.5);
			sprite.interactive = true;
			sprite.buttonMode = true;
			

			let body;
			if(bodyConfig === undefined || typeof bodyConfig !== "object") {
				body = Matter.Bodies.rectangle(x, y, sprite.width, sprite.height);
			} else {
				body = Matter.Bodies.rectangle(x, y, sprite.width, sprite.height, bodyConfig);
			}
			
			const entity = { 
				sprite: sprite,
				body: body
			};

			state.entities.push(entity);

			Matter.World.add(state.engine.world, body);
			state.app.stage.addChild(sprite);

		}


		function initPixi() {
			state.app = new PIXI.Application({ width: 800, height: 600 });
			PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;
			document.body.appendChild(state.app.view);
		}

		function initInput() {
			window.addEventListener('keyup', event => Key.onKeyup(event), false);
			window.addEventListener('keydown', event => Key.onKeydown(event), false);
		}

		function initSceneText() {
			drawText();

			addTextWithBody("new Date().getTime()", 100, 50, { frictionAir: 1 });
			addTextWithBody(new Date().getTime(), 100, 100);
			addTextWithBody("tiny", 100, 150);
			addTextWithBody("HUUUUUUUUUUUUUUUUGEEEEEEEE", 100, 200);
			addTextWithBody("yeafg", 100, 50, { frictionAir: 1 });
			
		}

		function initMatterEngine() {
			// module aliases
			var Engine = Matter.Engine,
				Render = Matter.Render,
				World = Matter.World,
				Bodies = Matter.Bodies,
				Body = Matter.Body,
				MouseConstraint = Matter.MouseConstraint,
				Mouse = Matter.Mouse,
				Events = Matter.Events;


			// create an engine
			var engine = Engine.create();
			engine.world.gravity.y = 0;
			state.engine = engine;
			var world = engine.world;

			// create a renderer
			var render = Render.create({
				element: document.body,
				engine: engine,
				options: {
					showAxes: true,
					showCollisions: true
				}
			});

		// let counter = 0;
		// Events.on(engine, 'beforeUpdate', function(event) {
		// 	counter += 1;
		// 	// every 1.5 sec
		// 	if (counter >= 60 * 0.7) {
				
		// 		Body.setVelocity(state.entities[0].body, { x: 0, y: -10 });
		// 		// Body.setAngle(bodyC, -Math.PI * 0.26);
		// 		// Body.setAngularVelocity(bodyD, 0.2);

		// 		// reset counter
		// 		counter = 0;
		// 	}
		// });
			

			// add mouse control
			var mouse = Mouse.create(render.canvas),
				mouseConstraint = MouseConstraint.create(engine, {
					mouse: mouse,
					constraint: {
						stiffness: 0.2,
						render: {
							visible: true
						}
					}
				});
			
			World.add(world, mouseConstraint);
			
			// create two boxes and a ground
			var ground = Bodies.rectangle(400, 610, 810, 60, { isStatic: true });
			var ceiling = Bodies.rectangle(400, 0, 810, 20, { isStatic: true });
			var leftWall = Bodies.rectangle(0, 310, 20, 700, { isStatic: true });
			var rightWall = Bodies.rectangle(800, 310, 20, 700, { isStatic: true });

			let bodies = [ground, ceiling, leftWall, rightWall];
			for(let i = 0; i < 25; i++) {
				const body = Bodies.circle(50+(i*10), 50+(i*10), 20, 20)
				bodies.push(body);
			}

			state.player.body = Bodies.rectangle(400, 300, 356, 53);
			bodies.push(state.player.body);

			// add all of the bodies to the world
			World.add(engine.world, bodies);

			// run the engine
			Engine.run(engine);

			// run the renderer
			Render.run(render);
		}

		function drawText(delta) {
			const style = new PIXI.TextStyle({
				fontFamily: 'Arial',
				fontSize: 36,
				fontStyle: 'italic',
				fontWeight: 'bold',
				fill: ['#ffffff', '#00ff99'], // gradient
				stroke: '#4a1850',
				strokeThickness: 5,
				dropShadow: true,
				dropShadowColor: '#000000',
				dropShadowBlur: 4,
				dropShadowAngle: Math.PI / 6,
				dropShadowDistance: 6,
				wordWrap: true,
				wordWrapWidth: 440
			});

			const textOriginal = 'flying text yay';
			const richText = new PIXI.Text(textOriginal, style);
			richText.x = state.app.renderer.width / 2;
			richText.y = state.app.renderer.height / 2;
			richText.anchor.set(0.5);
			richText.interactive = true;
			richText.buttonMode = true;
			richText.on('pointerdown', () => {
				richText.scale.x *= 1.25;
				richText.scale.y *= 1.25;
			});

			state.player.sprite = richText;
			state.app.stage.addChild(state.player.sprite);
			
		}


		function gameLoop(delta) {
			// Pause Logic
			if(Key.isDown(keycode.P)) {
				state.isPaused = !state.isPaused;
				Key._pressed[keycode.P] = null;
			}
			
			if(state.isPaused === true) {
				return;
			}
			
			// DEBUG 
			// console.log(Key._pressed);

			state.player.sprite.rotation += 0.02 * delta;
			// state.player.sprite.text = delta;
			state.player.sprite.text = 'Move with WASD';
			if(Object.keys(Key._pressed).length > 0) {
				state.player.sprite.text = '';
				for(key in Key._pressed) {
					state.player.sprite.text += ` ${key}`;
				}
			}

			let velocity = 0.3;
			if(Key.isDown(keycode.A) && Key.isDown(keycode.D)) {  }
			else if(Key.isDown(keycode.A)) { Matter.Body.applyForce(state.entities[0].body, { x: state.entities[0].body.position.x, y: state.entities[0].body.position.y }, { x: -velocity, y: 0 }); }
			else if(Key.isDown(keycode.D)) { Matter.Body.applyForce(state.entities[0].body, { x: state.entities[0].body.position.x, y: state.entities[0].body.position.y }, { x: velocity, y: 0 }); }
			else {  }

			if(Key.isDown(keycode.W) && Key.isDown(keycode.S)) {  }
			else if(Key.isDown(keycode.W)) { Matter.Body.applyForce(state.entities[0].body, { x: state.entities[0].body.position.x, y: state.entities[0].body.position.y }, { x: 0, y: -velocity }); }
			else if(Key.isDown(keycode.S)) { Matter.Body.applyForce(state.entities[0].body, { x: state.entities[0].body.position.x, y: state.entities[0].body.position.y }, { x: 0, y: velocity }); }
			else {  }


			if (Key.isDown(keycode.SPACE)) {
				state.player.sprite.scale.x *= 1.25;
				state.player.sprite.scale.y *= 1.25;

				Key._pressed[keycode.SPACE] = null;
			}
			if(Key.isDown(keycode.ESCAPE)) {
				state.player.sprite.scale.x *= 0.75;
				state.player.sprite.scale.y *= 0.75;

				Key._pressed[keycode.ESCAPE] = null;
			}
			
			state.player.sprite.x += state.player.sprite.vx;
			state.player.sprite.y += state.player.sprite.vy;
			
			// connect sprites with the bodies!
			for(entity of state.entities) {
				entity.sprite.rotation = entity.body.angle;
				entity.sprite.x = entity.body.position.x;
				entity.sprite.y = entity.body.position.y;
			}
			
			state.player.sprite.rotation = state.player.body.angle;
			state.player.sprite.x = state.player.body.position.x;
			state.player.sprite.y = state.player.body.position.y;

		}


		function main() {
			initPixi();
			initMatterEngine();
			initSceneText();
			initInput();
			
			// start gameloop
			state.app.ticker.add(delta => gameLoop(delta));
		}
	

		// start app
		main();
	</script>
</body>
</html>