<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>jsgame</title>
	<style>
		html,
		body {
			height: 100%;
			width: 100%;
			
			align-items: center;
			display: flex;
			justify-content: center;
			
			background-color: #1f2424;
			margin: 0;
		}
	</style>
</head>
<body>
	<script src="./vendor/pixijs/pixi.min.js"></script>
	<script src="./vendor/matter-js-0.12.0/build/matter.min.js"></script>
	
	<noscript>
		This site needs Javascript to function.
		Enable it or enjoy this blank page.
	</noscript>

	<!-- Game -->
	<script>

		// module aliases
		var Engine = Matter.Engine,
			Render = Matter.Render,
			World = Matter.World,
			Bodies = Matter.Bodies,
			MouseConstraint = Matter.MouseConstraint,
			Mouse = Matter.Mouse;


		// create an engine
		var engine = Engine.create();
		var world = engine.world;

		// create a renderer
		var render = Render.create({
			element: document.body,
			engine: engine,
			options: {
				showAxes: true,
				showCollisions: true
			}
		});

		// add mouse control
		var mouse = Mouse.create(render.canvas),
			mouseConstraint = MouseConstraint.create(engine, {
				mouse: mouse,
				constraint: {
					stiffness: 0.2,
					render: {
						visible: true
					}
				}
			});
		
		World.add(world, mouseConstraint);
		
		// create two boxes and a ground
		var ground = Bodies.rectangle(400, 610, 810, 60, { isStatic: true });
		var ceiling = Bodies.rectangle(400, 0, 810, 20, { isStatic: true });
		var leftWall = Bodies.rectangle(0, 310, 20, 700, { isStatic: true });
		var rightWall = Bodies.rectangle(800, 310, 20, 700, { isStatic: true });

		let bodies = [ground, ceiling, leftWall, rightWall];
		for(let i = 0; i < 25; i++) {
			const body = Bodies.circle(50+(i*10), 50+(i*10), 30, 30)
			bodies.push(body);
		}

		const textBody = Bodies.rectangle(400, 300, 100, 50);
		bodies.push(textBody);

		// add all of the bodies to the world
		World.add(engine.world, bodies);

		// run the engine
		Engine.run(engine);

		// run the renderer
		Render.run(render);

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////   END OF ENGINE   ////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
		const keycode = {
			W: 87,
			A: 65,
			S: 83,
			D: 68,
			P: 80,
			SPACE: 32,
			ESCAPE: 27
		};
		Object.freeze(keycode);
		
		const Key = {
			_pressed: {},
			
			isDown: function(keyCode) {
				return this._pressed[keyCode];
			},
			
			onKeydown: function(event) {
				if(this._pressed[event.keyCode] === undefined) {
					this._pressed[event.keyCode] = new Date().getTime();
				}
			},
			
			onKeyup: function(event) {
				delete this._pressed[event.keyCode];
			}
		};

		// Global state of the application
		const state = {
			app: null,
			player: {
				sprite: null,
				speed: 7
			},
			isPaused: false
		};


		function init() {
			state.app = new PIXI.Application({ width: 800, height: 600 });
			PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;
			document.body.appendChild(state.app.view);

			window.addEventListener('keyup', event => Key.onKeyup(event), false);
			window.addEventListener('keydown', event => Key.onKeydown(event), false);

			drawText();
		}


		function drawCircle() {
			const circle = new PIXI.Graphics();
			circle.beginFill(0x5cafe2);
			circle.drawCircle(0, 0, 80);
			circle.x = 320;
			circle.y = 180;
			state.app.stage.addChild(circle);
		}

		function drawText(delta) {
			const style = new PIXI.TextStyle({
				fontFamily: 'Arial',
				fontSize: 36,
				fontStyle: 'italic',
				fontWeight: 'bold',
				fill: ['#ffffff', '#00ff99'], // gradient
				stroke: '#4a1850',
				strokeThickness: 5,
				dropShadow: true,
				dropShadowColor: '#000000',
				dropShadowBlur: 4,
				dropShadowAngle: Math.PI / 6,
				dropShadowDistance: 6,
				wordWrap: true,
				wordWrapWidth: 440
			});

			const textOriginal = 'flying text yay';
			const richText = new PIXI.Text(textOriginal, style);
			richText.x = state.app.renderer.width / 2;
			richText.y = state.app.renderer.height / 2;
			richText.anchor.set(0.5);
			richText.interactive = true;
			richText.buttonMode = true;
			richText.on('pointerdown', () => {
				richText.scale.x *= 1.25;
				richText.scale.y *= 1.25;
			});

			state.player.sprite = richText;
			state.app.stage.addChild(state.player.sprite);
			
		}


		function gameLoop(delta) {

			
			// Pause Logic
			if(Key.isDown(keycode.P)) {
				state.isPaused = !state.isPaused;
				Key._pressed[keycode.P] = null;
			}
			
			if(state.isPaused === true) {
				return;
			}
			
			// DEBUG 
			// console.log(Key._pressed);

			state.player.sprite.rotation += 0.02 * delta;
			// state.player.sprite.text = delta;
			state.player.sprite.text = 'Move with WASD';
			if(Object.keys(Key._pressed).length > 0) {
				state.player.sprite.text = '';
				for(key in Key._pressed) {
					state.player.sprite.text += ` ${key}`;
				}
			}

			if(Key.isDown(keycode.A) && Key.isDown(keycode.D)) { state.player.sprite.vx = 0; }
			else if(Key.isDown(keycode.A)) { state.player.sprite.vx = -state.player.speed; }
			else if(Key.isDown(keycode.D)) { state.player.sprite.vx = state.player.speed; }
			else { state.player.sprite.vx = 0; }

			if(Key.isDown(keycode.W) && Key.isDown(keycode.S)) { state.player.sprite.vy = 0; }
			else if(Key.isDown(keycode.W)) { state.player.sprite.vy = -state.player.speed; }
			else if(Key.isDown(keycode.S)) { state.player.sprite.vy = state.player.speed; }
			else { state.player.sprite.vy = 0; }


			if (Key.isDown(keycode.SPACE)) {
				state.player.sprite.scale.x *= 1.25;
				state.player.sprite.scale.y *= 1.25;

				Key._pressed[keycode.SPACE] = null;
			}
			if(Key.isDown(keycode.ESCAPE)) {
				state.player.sprite.scale.x *= 0.75;
				state.player.sprite.scale.y *= 0.75;

				Key._pressed[keycode.ESCAPE] = null;
			}
			
			state.player.sprite.x += state.player.sprite.vx;
			state.player.sprite.y += state.player.sprite.vy;
			
			Matter.Body.setAngle(textBody, state.player.sprite.rotation);
			Matter.Body.setPosition(textBody, {x: state.player.sprite.x, y: state.player.sprite.y});

		}


		function main() {
			init();
			state.app.ticker.add(delta => gameLoop(delta));
		}
	

		// start app
		main();
	</script>
</body>
</html>